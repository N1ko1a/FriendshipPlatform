{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.recoverAddress = exports.computeAddress = void 0;\nconst index_js_1 = require(\"../address/index.js\");\nconst index_js_2 = require(\"../crypto/index.js\");\n/**\n *  Returns the address for the %%key%%.\n *\n *  The key may be any standard form of public key or a private key.\n */\nfunction computeAddress(key) {\n  let pubkey;\n  if (typeof key === \"string\") {\n    pubkey = index_js_2.SigningKey.computePublicKey(key, false);\n  } else {\n    pubkey = key.publicKey;\n  }\n  return (0, index_js_1.getAddress)((0, index_js_2.keccak256)(\"0x\" + pubkey.substring(4)).substring(26));\n}\nexports.computeAddress = computeAddress;\n/**\n *  Returns the recovered address for the private key that was\n *  used to sign %%digest%% that resulted in %%signature%%.\n */\nfunction recoverAddress(digest, signature) {\n  return computeAddress(index_js_2.SigningKey.recoverPublicKey(digest, signature));\n}\nexports.recoverAddress = recoverAddress;","map":{"version":3,"names":["index_js_1","require","index_js_2","computeAddress","key","pubkey","SigningKey","computePublicKey","publicKey","getAddress","keccak256","substring","exports","recoverAddress","digest","signature","recoverPublicKey"],"sources":["/home/nikola/Nikola/GitHub/FriendshipPlatform/node_modules/ethers/src.ts/transaction/address.ts"],"sourcesContent":["import { getAddress } from \"../address/index.js\";\nimport { keccak256, SigningKey } from \"../crypto/index.js\";\n\nimport type { SignatureLike } from \"../crypto/index.js\";\nimport type { BytesLike } from \"../utils/index.js\";\n\n/**\n *  Returns the address for the %%key%%.\n *\n *  The key may be any standard form of public key or a private key.\n */\nexport function computeAddress(key: string | SigningKey): string {\n    let pubkey: string;\n    if (typeof(key) === \"string\") {\n        pubkey = SigningKey.computePublicKey(key, false);\n    } else {\n        pubkey = key.publicKey;\n    }\n    return getAddress(keccak256(\"0x\" + pubkey.substring(4)).substring(26));\n}\n\n/**\n *  Returns the recovered address for the private key that was\n *  used to sign %%digest%% that resulted in %%signature%%.\n */\nexport function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(SigningKey.recoverPublicKey(digest, signature));\n}\n"],"mappings":";;;;;;AAAA,MAAAA,UAAA,GAAAC,OAAA;AACA,MAAAC,UAAA,GAAAD,OAAA;AAKA;;;;;AAKA,SAAgBE,cAAcA,CAACC,GAAwB;EACnD,IAAIC,MAAc;EAClB,IAAI,OAAOD,GAAI,KAAK,QAAQ,EAAE;IAC1BC,MAAM,GAAGH,UAAA,CAAAI,UAAU,CAACC,gBAAgB,CAACH,GAAG,EAAE,KAAK,CAAC;GACnD,MAAM;IACHC,MAAM,GAAGD,GAAG,CAACI,SAAS;;EAE1B,OAAO,IAAAR,UAAA,CAAAS,UAAU,EAAC,IAAAP,UAAA,CAAAQ,SAAS,EAAC,IAAI,GAAGL,MAAM,CAACM,SAAS,CAAC,CAAC,CAAC,CAAC,CAACA,SAAS,CAAC,EAAE,CAAC,CAAC;AAC1E;AARAC,OAAA,CAAAT,cAAA,GAAAA,cAAA;AAUA;;;;AAIA,SAAgBU,cAAcA,CAACC,MAAiB,EAAEC,SAAwB;EACtE,OAAOZ,cAAc,CAACD,UAAA,CAAAI,UAAU,CAACU,gBAAgB,CAACF,MAAM,EAAEC,SAAS,CAAC,CAAC;AACzE;AAFAH,OAAA,CAAAC,cAAA,GAAAA,cAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zeroPadBytes = exports.zeroPadValue = exports.stripZerosLeft = exports.dataSlice = exports.dataLength = exports.concat = exports.hexlify = exports.isBytesLike = exports.isHexString = exports.getBytesCopy = exports.getBytes = void 0;\n/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\nconst errors_js_1 = require(\"./errors.js\");\nfunction _getBytes(value, name, copy) {\n  if (value instanceof Uint8Array) {\n    if (copy) {\n      return new Uint8Array(value);\n    }\n    return value;\n  }\n  if (typeof value === \"string\" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\n    const result = new Uint8Array((value.length - 2) / 2);\n    let offset = 2;\n    for (let i = 0; i < result.length; i++) {\n      result[i] = parseInt(value.substring(offset, offset + 2), 16);\n      offset += 2;\n    }\n    return result;\n  }\n  (0, errors_js_1.assertArgument)(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nfunction getBytes(value, name) {\n  return _getBytes(value, name, false);\n}\nexports.getBytes = getBytes;\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nfunction getBytesCopy(value, name) {\n  return _getBytes(value, name, true);\n}\nexports.getBytesCopy = getBytesCopy;\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nfunction isHexString(value, length) {\n  if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n  if (typeof length === \"number\" && value.length !== 2 + 2 * length) {\n    return false;\n  }\n  if (length === true && value.length % 2 !== 0) {\n    return false;\n  }\n  return true;\n}\nexports.isHexString = isHexString;\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nfunction isBytesLike(value) {\n  return isHexString(value, true) || value instanceof Uint8Array;\n}\nexports.isBytesLike = isBytesLike;\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nfunction hexlify(data) {\n  const bytes = getBytes(data);\n  let result = \"0x\";\n  for (let i = 0; i < bytes.length; i++) {\n    const v = bytes[i];\n    result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n  }\n  return result;\n}\nexports.hexlify = hexlify;\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nfunction concat(datas) {\n  return \"0x\" + datas.map(d => hexlify(d).substring(2)).join(\"\");\n}\nexports.concat = concat;\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nfunction dataLength(data) {\n  if (isHexString(data, true)) {\n    return (data.length - 2) / 2;\n  }\n  return getBytes(data).length;\n}\nexports.dataLength = dataLength;\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nfunction dataSlice(data, start, end) {\n  const bytes = getBytes(data);\n  if (end != null && end > bytes.length) {\n    (0, errors_js_1.assert)(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n      buffer: bytes,\n      length: bytes.length,\n      offset: end\n    });\n  }\n  return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));\n}\nexports.dataSlice = dataSlice;\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\nfunction stripZerosLeft(data) {\n  let bytes = hexlify(data).substring(2);\n  while (bytes.startsWith(\"00\")) {\n    bytes = bytes.substring(2);\n  }\n  return \"0x\" + bytes;\n}\nexports.stripZerosLeft = stripZerosLeft;\nfunction zeroPad(data, length, left) {\n  const bytes = getBytes(data);\n  (0, errors_js_1.assert)(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n    buffer: new Uint8Array(bytes),\n    length: length,\n    offset: length + 1\n  });\n  const result = new Uint8Array(length);\n  result.fill(0);\n  if (left) {\n    result.set(bytes, length - bytes.length);\n  } else {\n    result.set(bytes, 0);\n  }\n  return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nfunction zeroPadValue(data, length) {\n  return zeroPad(data, length, true);\n}\nexports.zeroPadValue = zeroPadValue;\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nfunction zeroPadBytes(data, length) {\n  return zeroPad(data, length, false);\n}\nexports.zeroPadBytes = zeroPadBytes;","map":{"version":3,"names":["errors_js_1","require","_getBytes","value","name","copy","Uint8Array","match","result","length","offset","i","parseInt","substring","assertArgument","getBytes","exports","getBytesCopy","isHexString","isBytesLike","HexCharacters","hexlify","data","bytes","v","concat","datas","map","d","join","dataLength","dataSlice","start","end","assert","buffer","slice","stripZerosLeft","startsWith","zeroPad","left","fill","set","zeroPadValue","zeroPadBytes"],"sources":["/home/nikola/Desktop/Kriptografija projekat Nikola Ivanovic 637-2019/friendship-dapp/node_modules/ethers/src.ts/utils/data.ts"],"sourcesContent":["/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\nimport { assert, assertArgument } from \"./errors.js\";\n\n/**\n *  A [[HexString]] whose length is even, which ensures it is a valid\n *  representation of binary data.\n */\nexport type DataHexString = string;\n\n/**\n *  A string which is prefixed with ``0x`` and followed by any number\n *  of case-agnostic hexadecimal characters.\n *\n *  It must match the regular expression ``/0x[0-9A-Fa-f]*\\/``.\n */\nexport type HexString = string;\n\n/**\n *  An object that can be used to represent binary data.\n */\nexport type BytesLike = DataHexString | Uint8Array;\n\nfunction _getBytes(value: BytesLike, name?: string, copy?: boolean): Uint8Array {\n    if (value instanceof Uint8Array) {\n        if (copy) { return new Uint8Array(value); }\n        return value;\n    }\n\n    if (typeof(value) === \"string\" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for (let i = 0; i < result.length; i++) {\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n\n    assertArgument(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nexport function getBytes(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, false);\n}\n\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nexport function getBytesCopy(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, true);\n}\n\n\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nexport function isHexString(value: any, length?: number | boolean): value is `0x${ string }` {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n\n    if (typeof(length) === \"number\" && value.length !== 2 + 2 * length) { return false; }\n    if (length === true && (value.length % 2) !== 0) { return false; }\n\n    return true;\n}\n\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nexport function isBytesLike(value: any): value is BytesLike {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nexport function hexlify(data: BytesLike): string {\n    const bytes = getBytes(data);\n\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nexport function concat(datas: ReadonlyArray<BytesLike>): string {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}\n\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nexport function dataLength(data: BytesLike): number {\n    if (isHexString(data, true)) { return (data.length - 2) / 2; }\n    return getBytes(data).length;\n}\n\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nexport function dataSlice(data: BytesLike, start?: number, end?: number): string {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n        });\n    }\n    return hexlify(bytes.slice((start == null) ? 0: start, (end == null) ? bytes.length: end));\n}\n\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\nexport function stripZerosLeft(data: BytesLike): string {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) { bytes = bytes.substring(2); }\n    return \"0x\" + bytes;\n}\n\nfunction zeroPad(data: BytesLike, length: number, left: boolean): string {\n    const bytes = getBytes(data);\n    assert(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    } else {\n        result.set(bytes, 0);\n    }\n\n    return hexlify(result);\n}\n\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nexport function zeroPadValue(data: BytesLike, length: number): string {\n    return zeroPad(data, length, true);\n}\n\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nexport function zeroPadBytes(data: BytesLike, length: number): string {\n    return zeroPad(data, length, false);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
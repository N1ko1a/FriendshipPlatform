{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PollingEventSubscriber = exports.PollingTransactionSubscriber = exports.PollingOrphanSubscriber = exports.OnBlockSubscriber = exports.PollingBlockSubscriber = exports.getPollingSubscriber = void 0;\nconst index_js_1 = require(\"../utils/index.js\");\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nfunction getPollingSubscriber(provider, event) {\n  if (event === \"block\") {\n    return new PollingBlockSubscriber(provider);\n  }\n  if ((0, index_js_1.isHexString)(event, 32)) {\n    return new PollingTransactionSubscriber(provider, event);\n  }\n  (0, index_js_1.assert)(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"getPollingSubscriber\",\n    info: {\n      event\n    }\n  });\n}\nexports.getPollingSubscriber = getPollingSubscriber;\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingBlockSubscriber {\n  #provider;\n  #poller;\n  #interval;\n  // The most recent block we have scanned for events. The value -2\n  // indicates we still need to fetch an initial block number\n  #blockNumber;\n  /**\n   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n   */\n  constructor(provider) {\n    this.#provider = provider;\n    this.#poller = null;\n    this.#interval = 4000;\n    this.#blockNumber = -2;\n  }\n  /**\n   *  The polling interval.\n   */\n  get pollingInterval() {\n    return this.#interval;\n  }\n  set pollingInterval(value) {\n    this.#interval = value;\n  }\n  async #poll() {\n    try {\n      const blockNumber = await this.#provider.getBlockNumber();\n      // Bootstrap poll to setup our initial block number\n      if (this.#blockNumber === -2) {\n        this.#blockNumber = blockNumber;\n        return;\n      }\n      // @TODO: Put a cap on the maximum number of events per loop?\n      if (blockNumber !== this.#blockNumber) {\n        for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n          // We have been stopped\n          if (this.#poller == null) {\n            return;\n          }\n          await this.#provider.emit(\"block\", b);\n        }\n        this.#blockNumber = blockNumber;\n      }\n    } catch (error) {\n      // @TODO: Minor bump, add an \"error\" event to let subscribers\n      //        know things went awry.\n      //console.log(error);\n    }\n    // We have been stopped\n    if (this.#poller == null) {\n      return;\n    }\n    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n  }\n  start() {\n    if (this.#poller) {\n      return;\n    }\n    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    this.#poll();\n  }\n  stop() {\n    if (!this.#poller) {\n      return;\n    }\n    this.#provider._clearTimeout(this.#poller);\n    this.#poller = null;\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      this.#blockNumber = -2;\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\nexports.PollingBlockSubscriber = PollingBlockSubscriber;\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass OnBlockSubscriber {\n  #provider;\n  #poll;\n  #running;\n  /**\n   *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n   */\n  constructor(provider) {\n    this.#provider = provider;\n    this.#running = false;\n    this.#poll = blockNumber => {\n      this._poll(blockNumber, this.#provider);\n    };\n  }\n  /**\n   *  Called on every new block.\n   */\n  async _poll(blockNumber, provider) {\n    throw new Error(\"sub-classes must override this\");\n  }\n  start() {\n    if (this.#running) {\n      return;\n    }\n    this.#running = true;\n    this.#poll(-2);\n    this.#provider.on(\"block\", this.#poll);\n  }\n  stop() {\n    if (!this.#running) {\n      return;\n    }\n    this.#running = false;\n    this.#provider.off(\"block\", this.#poll);\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n  }\n  resume() {\n    this.start();\n  }\n}\nexports.OnBlockSubscriber = OnBlockSubscriber;\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingOrphanSubscriber extends OnBlockSubscriber {\n  #filter;\n  constructor(provider, filter) {\n    super(provider);\n    this.#filter = copy(filter);\n  }\n  async _poll(blockNumber, provider) {\n    throw new Error(\"@TODO\");\n    console.log(this.#filter);\n  }\n}\nexports.PollingOrphanSubscriber = PollingOrphanSubscriber;\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingTransactionSubscriber extends OnBlockSubscriber {\n  #hash;\n  /**\n   *  Create a new **PollingTransactionSubscriber** attached to\n   *  %%provider%%, listening for %%hash%%.\n   */\n  constructor(provider, hash) {\n    super(provider);\n    this.#hash = hash;\n  }\n  async _poll(blockNumber, provider) {\n    const tx = await provider.getTransactionReceipt(this.#hash);\n    if (tx) {\n      provider.emit(this.#hash, tx);\n    }\n  }\n}\nexports.PollingTransactionSubscriber = PollingTransactionSubscriber;\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingEventSubscriber {\n  #provider;\n  #filter;\n  #poller;\n  #running;\n  // The most recent block we have scanned for events. The value -2\n  // indicates we still need to fetch an initial block number\n  #blockNumber;\n  /**\n   *  Create a new **PollingTransactionSubscriber** attached to\n   *  %%provider%%, listening for %%filter%%.\n   */\n  constructor(provider, filter) {\n    this.#provider = provider;\n    this.#filter = copy(filter);\n    this.#poller = this.#poll.bind(this);\n    this.#running = false;\n    this.#blockNumber = -2;\n  }\n  async #poll(blockNumber) {\n    // The initial block hasn't been determined yet\n    if (this.#blockNumber === -2) {\n      return;\n    }\n    const filter = copy(this.#filter);\n    filter.fromBlock = this.#blockNumber + 1;\n    filter.toBlock = blockNumber;\n    const logs = await this.#provider.getLogs(filter);\n    // No logs could just mean the node has not indexed them yet,\n    // so we keep a sliding window of 60 blocks to keep scanning\n    if (logs.length === 0) {\n      if (this.#blockNumber < blockNumber - 60) {\n        this.#blockNumber = blockNumber - 60;\n      }\n      return;\n    }\n    for (const log of logs) {\n      this.#provider.emit(this.#filter, log);\n      // Only advance the block number when logs were found to\n      // account for networks (like BNB and Polygon) which may\n      // sacrifice event consistency for block event speed\n      this.#blockNumber = log.blockNumber;\n    }\n  }\n  start() {\n    if (this.#running) {\n      return;\n    }\n    this.#running = true;\n    if (this.#blockNumber === -2) {\n      this.#provider.getBlockNumber().then(blockNumber => {\n        this.#blockNumber = blockNumber;\n      });\n    }\n    this.#provider.on(\"block\", this.#poller);\n  }\n  stop() {\n    if (!this.#running) {\n      return;\n    }\n    this.#running = false;\n    this.#provider.off(\"block\", this.#poller);\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      this.#blockNumber = -2;\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\nexports.PollingEventSubscriber = PollingEventSubscriber;","map":{"version":3,"names":["index_js_1","require","copy","obj","JSON","parse","stringify","getPollingSubscriber","provider","event","PollingBlockSubscriber","isHexString","PollingTransactionSubscriber","assert","operation","info","exports","poller","interval","blockNumber","constructor","pollingInterval","value","poll","#poll","getBlockNumber","b","emit","error","_setTimeout","bind","start","stop","_clearTimeout","pause","dropWhilePaused","resume","OnBlockSubscriber","running","_poll","Error","on","off","PollingOrphanSubscriber","filter","console","log","hash","tx","getTransactionReceipt","PollingEventSubscriber","fromBlock","toBlock","logs","getLogs","length","then"],"sources":["/home/nikola/Nikola/GitHub/FriendshipPlatform/node_modules/ethers/src.ts/providers/subscriber-polling.ts"],"sourcesContent":["import { assert, isHexString } from \"../utils/index.js\";\n\nimport type { AbstractProvider, Subscriber } from \"./abstract-provider.js\";\nimport type { EventFilter, OrphanFilter, ProviderEvent } from \"./provider.js\";\n\nfunction copy(obj: any): any {\n    return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport function getPollingSubscriber(provider: AbstractProvider, event: ProviderEvent): Subscriber {\n    if (event === \"block\") { return new PollingBlockSubscriber(provider); }\n    if (isHexString(event, 32)) { return new PollingTransactionSubscriber(provider, event); }\n\n    assert(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\", info: { event }\n    });\n}\n\n// @TODO: refactor this\n\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingBlockSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #poller: null | number;\n\n    #interval: number;\n\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber: number;\n\n    /**\n     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider: AbstractProvider) {\n        this.#provider = provider;\n        this.#poller = null;\n        this.#interval = 4000;\n\n        this.#blockNumber = -2;\n    }\n\n    /**\n     *  The polling interval.\n     */\n    get pollingInterval(): number { return this.#interval; }\n    set pollingInterval(value: number) { this.#interval = value; }\n\n    async #poll(): Promise<void> {\n        try {\n            const blockNumber = await this.#provider.getBlockNumber();\n\n            // Bootstrap poll to setup our initial block number\n            if (this.#blockNumber === -2) {\n                this.#blockNumber = blockNumber;\n                return;\n            }\n\n            // @TODO: Put a cap on the maximum number of events per loop?\n\n            if (blockNumber !== this.#blockNumber) {\n                for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n                    // We have been stopped\n                    if (this.#poller == null) { return; }\n\n                    await this.#provider.emit(\"block\", b);\n                }\n\n                this.#blockNumber = blockNumber;\n            }\n\n        } catch (error) {\n            // @TODO: Minor bump, add an \"error\" event to let subscribers\n            //        know things went awry.\n            //console.log(error);\n        }\n\n        // We have been stopped\n        if (this.#poller == null) { return; }\n\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    }\n\n    start(): void {\n        if (this.#poller) { return; }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n        this.#poll();\n    }\n\n    stop(): void {\n        if (!this.#poller) { return; }\n        this.#provider._clearTimeout(this.#poller);\n        this.#poller = null;\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        this.stop();\n        if (dropWhilePaused) { this.#blockNumber = -2; }\n    }\n\n    resume(): void {\n        this.start();\n    }\n}\n\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class OnBlockSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #poll: (b: number) => void;\n    #running: boolean;\n\n    /**\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider: AbstractProvider) {\n        this.#provider = provider;\n        this.#running = false;\n        this.#poll = (blockNumber: number) => {\n            this._poll(blockNumber, this.#provider);\n        }\n    }\n\n    /**\n     *  Called on every new block.\n     */\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        throw new Error(\"sub-classes must override this\");\n    }\n\n    start(): void {\n        if (this.#running) { return; }\n        this.#running = true;\n\n        this.#poll(-2);\n        this.#provider.on(\"block\", this.#poll);\n    }\n\n    stop(): void {\n        if (!this.#running) { return; }\n        this.#running = false;\n\n        this.#provider.off(\"block\", this.#poll);\n    }\n\n    pause(dropWhilePaused?: boolean): void { this.stop(); }\n    resume(): void { this.start(); }\n}\n\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter: OrphanFilter;\n\n    constructor(provider: AbstractProvider, filter: OrphanFilter) {\n        super(provider);\n        this.#filter = copy(filter);\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        throw new Error(\"@TODO\");\n        console.log(this.#filter);\n    }\n}\n\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash: string;\n\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%hash%%.\n     */\n    constructor(provider: AbstractProvider, hash: string) {\n        super(provider);\n        this.#hash = hash;\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        const tx = await provider.getTransactionReceipt(this.#hash);\n        if (tx) { provider.emit(this.#hash, tx); }\n    }\n}\n\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingEventSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #filter: EventFilter;\n    #poller: (b: number) => void;\n\n    #running: boolean;\n\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber: number;\n\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%filter%%.\n     */\n    constructor(provider: AbstractProvider, filter: EventFilter) {\n        this.#provider = provider;\n        this.#filter = copy(filter);\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#blockNumber = -2;\n    }\n\n    async #poll(blockNumber: number): Promise<void> {\n        // The initial block hasn't been determined yet\n        if (this.#blockNumber === -2) { return; }\n\n        const filter = copy(this.#filter);\n        filter.fromBlock = this.#blockNumber + 1;\n        filter.toBlock = blockNumber;\n\n        const logs = await this.#provider.getLogs(filter);\n\n        // No logs could just mean the node has not indexed them yet,\n        // so we keep a sliding window of 60 blocks to keep scanning\n        if (logs.length === 0) {\n            if (this.#blockNumber < blockNumber - 60) {\n                this.#blockNumber = blockNumber - 60;\n            }\n            return;\n        }\n\n        for (const log of logs) {\n            this.#provider.emit(this.#filter, log);\n\n            // Only advance the block number when logs were found to\n            // account for networks (like BNB and Polygon) which may\n            // sacrifice event consistency for block event speed\n            this.#blockNumber = log.blockNumber;\n        }\n    }\n\n    start(): void {\n        if (this.#running) { return; }\n        this.#running = true;\n\n        if (this.#blockNumber === -2) {\n            this.#provider.getBlockNumber().then((blockNumber) => {\n                this.#blockNumber = blockNumber;\n            });\n        }\n        this.#provider.on(\"block\", this.#poller);\n    }\n\n    stop(): void {\n        if (!this.#running) { return; }\n        this.#running = false;\n\n        this.#provider.off(\"block\", this.#poller);\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        this.stop();\n        if (dropWhilePaused) { this.#blockNumber = -2; }\n    }\n\n    resume(): void {\n        this.start();\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getUrl = void 0;\nconst errors_js_1 = require(\"./errors.js\");\n// @TODO: timeout is completely ignored; start a Promise.any with a reject?\nasync function getUrl(req, _signal) {\n  const protocol = req.url.split(\":\")[0].toLowerCase();\n  (0, errors_js_1.assert)(protocol === \"http\" || protocol === \"https\", `unsupported protocol ${protocol}`, \"UNSUPPORTED_OPERATION\", {\n    info: {\n      protocol\n    },\n    operation: \"request\"\n  });\n  (0, errors_js_1.assert)(protocol === \"https\" || !req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"request\"\n  });\n  let signal = undefined;\n  if (_signal) {\n    const controller = new AbortController();\n    signal = controller.signal;\n    _signal.addListener(() => {\n      controller.abort();\n    });\n  }\n  const init = {\n    method: req.method,\n    headers: new Headers(Array.from(req)),\n    body: req.body || undefined,\n    signal\n  };\n  const resp = await fetch(req.url, init);\n  const headers = {};\n  resp.headers.forEach((value, key) => {\n    headers[key.toLowerCase()] = value;\n  });\n  const respBody = await resp.arrayBuffer();\n  const body = respBody == null ? null : new Uint8Array(respBody);\n  return {\n    statusCode: resp.status,\n    statusMessage: resp.statusText,\n    headers,\n    body\n  };\n}\nexports.getUrl = getUrl;","map":{"version":3,"names":["errors_js_1","require","getUrl","req","_signal","protocol","url","split","toLowerCase","assert","info","operation","credentials","allowInsecureAuthentication","signal","undefined","controller","AbortController","addListener","abort","init","method","headers","Headers","Array","from","body","resp","fetch","forEach","value","key","respBody","arrayBuffer","Uint8Array","statusCode","status","statusMessage","statusText","exports"],"sources":["/home/nikola/Nikola/GitHub/FriendshipPlatform/node_modules/ethers/src.ts/utils/geturl-browser.ts"],"sourcesContent":["import { assert } from \"./errors.js\";\n\nimport type { FetchRequest, FetchCancelSignal, GetUrlResponse } from \"./fetch.js\";\n\n\ndeclare global {\n    class Headers {\n        constructor(values: Array<[ string, string ]>);\n        forEach(func: (v: string, k: string) => void): void;\n    }\n\n    class Response {\n        status: number;\n        statusText: string;\n        headers: Headers;\n        arrayBuffer(): Promise<ArrayBuffer>;\n    }\n\n    type FetchInit = {\n        method?: string,\n        headers?: Headers,\n        body?: Uint8Array\n    };\n\n    function fetch(url: string, init: FetchInit): Promise<Response>;\n}\n\n// @TODO: timeout is completely ignored; start a Promise.any with a reject?\n\nexport async function getUrl(req: FetchRequest, _signal?: FetchCancelSignal): Promise<GetUrlResponse> {\n    const protocol = req.url.split(\":\")[0].toLowerCase();\n\n    assert(protocol === \"http\" || protocol === \"https\", `unsupported protocol ${ protocol }`, \"UNSUPPORTED_OPERATION\", {\n        info: { protocol },\n        operation: \"request\"\n    });\n\n    assert(protocol === \"https\" || !req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"request\"\n    });\n\n    let signal: undefined | AbortSignal = undefined;\n    if (_signal) {\n        const controller = new AbortController();\n        signal = controller.signal;\n        _signal.addListener(() => { controller.abort(); });\n    }\n\n    const init = {\n        method: req.method,\n        headers: new Headers(Array.from(req)),\n        body: req.body || undefined,\n        signal\n    };\n\n    const resp = await fetch(req.url, init);\n\n    const headers: Record<string, string> = { };\n    resp.headers.forEach((value, key) => {\n        headers[key.toLowerCase()] = value;\n    });\n\n    const respBody = await resp.arrayBuffer();\n    const body = (respBody == null) ? null: new Uint8Array(respBody);\n\n    return {\n        statusCode: resp.status,\n        statusMessage: resp.statusText,\n        headers, body\n    };\n}\n\n"],"mappings":";;;;;;AAAA,MAAAA,WAAA,GAAAC,OAAA;AA2BA;AAEO,eAAeC,MAAMA,CAACC,GAAiB,EAAEC,OAA2B;EACvE,MAAMC,QAAQ,GAAGF,GAAG,CAACG,GAAG,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAACC,WAAW,EAAE;EAEpD,IAAAR,WAAA,CAAAS,MAAM,EAACJ,QAAQ,KAAK,MAAM,IAAIA,QAAQ,KAAK,OAAO,EAAE,wBAAyBA,QAAS,EAAE,EAAE,uBAAuB,EAAE;IAC/GK,IAAI,EAAE;MAAEL;IAAQ,CAAE;IAClBM,SAAS,EAAE;GACd,CAAC;EAEF,IAAAX,WAAA,CAAAS,MAAM,EAACJ,QAAQ,KAAK,OAAO,IAAI,CAACF,GAAG,CAACS,WAAW,IAAIT,GAAG,CAACU,2BAA2B,EAAE,6CAA6C,EAAE,uBAAuB,EAAE;IACxJF,SAAS,EAAE;GACd,CAAC;EAEF,IAAIG,MAAM,GAA4BC,SAAS;EAC/C,IAAIX,OAAO,EAAE;IACT,MAAMY,UAAU,GAAG,IAAIC,eAAe,EAAE;IACxCH,MAAM,GAAGE,UAAU,CAACF,MAAM;IAC1BV,OAAO,CAACc,WAAW,CAAC,MAAK;MAAGF,UAAU,CAACG,KAAK,EAAE;IAAE,CAAC,CAAC;;EAGtD,MAAMC,IAAI,GAAG;IACTC,MAAM,EAAElB,GAAG,CAACkB,MAAM;IAClBC,OAAO,EAAE,IAAIC,OAAO,CAACC,KAAK,CAACC,IAAI,CAACtB,GAAG,CAAC,CAAC;IACrCuB,IAAI,EAAEvB,GAAG,CAACuB,IAAI,IAAIX,SAAS;IAC3BD;GACH;EAED,MAAMa,IAAI,GAAG,MAAMC,KAAK,CAACzB,GAAG,CAACG,GAAG,EAAEc,IAAI,CAAC;EAEvC,MAAME,OAAO,GAA2B,EAAG;EAC3CK,IAAI,CAACL,OAAO,CAACO,OAAO,CAAC,CAACC,KAAK,EAAEC,GAAG,KAAI;IAChCT,OAAO,CAACS,GAAG,CAACvB,WAAW,EAAE,CAAC,GAAGsB,KAAK;EACtC,CAAC,CAAC;EAEF,MAAME,QAAQ,GAAG,MAAML,IAAI,CAACM,WAAW,EAAE;EACzC,MAAMP,IAAI,GAAIM,QAAQ,IAAI,IAAI,GAAI,IAAI,GAAE,IAAIE,UAAU,CAACF,QAAQ,CAAC;EAEhE,OAAO;IACHG,UAAU,EAAER,IAAI,CAACS,MAAM;IACvBC,aAAa,EAAEV,IAAI,CAACW,UAAU;IAC9BhB,OAAO;IAAEI;GACZ;AACL;AAzCAa,OAAA,CAAArC,MAAA,GAAAA,MAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}
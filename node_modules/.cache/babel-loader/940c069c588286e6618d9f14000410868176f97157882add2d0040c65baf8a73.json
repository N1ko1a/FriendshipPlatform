{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NonceManager = void 0;\nconst index_js_1 = require(\"../utils/index.js\");\nconst abstract_signer_js_1 = require(\"./abstract-signer.js\");\n/**\n *  A **NonceManager** wraps another [[Signer]] and automatically manages\n *  the nonce, ensuring serialized and sequential nonces are used during\n *  transaction.\n */\nclass NonceManager extends abstract_signer_js_1.AbstractSigner {\n  /**\n   *  The Signer being managed.\n   */\n  signer;\n  #noncePromise;\n  #delta;\n  /**\n   *  Creates a new **NonceManager** to manage %%signer%%.\n   */\n  constructor(signer) {\n    super(signer.provider);\n    (0, index_js_1.defineProperties)(this, {\n      signer\n    });\n    this.#noncePromise = null;\n    this.#delta = 0;\n  }\n  async getAddress() {\n    return this.signer.getAddress();\n  }\n  connect(provider) {\n    return new NonceManager(this.signer.connect(provider));\n  }\n  async getNonce(blockTag) {\n    if (blockTag === \"pending\") {\n      if (this.#noncePromise == null) {\n        this.#noncePromise = super.getNonce(\"pending\");\n      }\n      const delta = this.#delta;\n      return (await this.#noncePromise) + delta;\n    }\n    return super.getNonce(blockTag);\n  }\n  /**\n   *  Manually increment the nonce. This may be useful when managng\n   *  offline transactions.\n   */\n  increment() {\n    this.#delta++;\n  }\n  /**\n   *  Resets the nonce, causing the **NonceManager** to reload the current\n   *  nonce from the blockchain on the next transaction.\n   */\n  reset() {\n    this.#delta = 0;\n    this.#noncePromise = null;\n  }\n  async sendTransaction(tx) {\n    const noncePromise = this.getNonce(\"pending\");\n    this.increment();\n    tx = await this.signer.populateTransaction(tx);\n    tx.nonce = await noncePromise;\n    // @TODO: Maybe handle interesting/recoverable errors?\n    // Like don't increment if the tx was certainly not sent\n    return await this.signer.sendTransaction(tx);\n  }\n  signTransaction(tx) {\n    return this.signer.signTransaction(tx);\n  }\n  signMessage(message) {\n    return this.signer.signMessage(message);\n  }\n  signTypedData(domain, types, value) {\n    return this.signer.signTypedData(domain, types, value);\n  }\n}\nexports.NonceManager = NonceManager;","map":{"version":3,"names":["index_js_1","require","abstract_signer_js_1","NonceManager","AbstractSigner","signer","noncePromise","delta","constructor","provider","defineProperties","getAddress","connect","getNonce","blockTag","increment","reset","sendTransaction","tx","populateTransaction","nonce","signTransaction","signMessage","message","signTypedData","domain","types","value","exports"],"sources":["/home/nikola/Desktop/Projekat/friendship-dapp/node_modules/ethers/src.ts/providers/signer-noncemanager.ts"],"sourcesContent":["import { defineProperties } from \"../utils/index.js\";\nimport { AbstractSigner } from \"./abstract-signer.js\";\n\nimport type { TypedDataDomain, TypedDataField } from \"../hash/index.js\";\n\nimport type {\n    BlockTag, Provider, TransactionRequest, TransactionResponse\n} from \"./provider.js\";\nimport type { Signer } from \"./signer.js\";\n\n\n/**\n *  A **NonceManager** wraps another [[Signer]] and automatically manages\n *  the nonce, ensuring serialized and sequential nonces are used during\n *  transaction.\n */\nexport class NonceManager extends AbstractSigner {\n    /**\n     *  The Signer being managed.\n     */\n    signer!: Signer;\n\n    #noncePromise: null | Promise<number>;\n    #delta: number;\n\n    /**\n     *  Creates a new **NonceManager** to manage %%signer%%.\n     */\n    constructor(signer: Signer) {\n        super(signer.provider);\n        defineProperties<NonceManager>(this, { signer });\n\n        this.#noncePromise = null;\n        this.#delta = 0;\n    }\n\n    async getAddress(): Promise<string> {\n        return this.signer.getAddress();\n    }\n\n    connect(provider: null | Provider): NonceManager {\n        return new NonceManager(this.signer.connect(provider));\n    }\n\n    async getNonce(blockTag?: BlockTag): Promise<number> {\n        if (blockTag === \"pending\") {\n            if (this.#noncePromise == null) {\n                this.#noncePromise = super.getNonce(\"pending\");\n            }\n\n            const delta = this.#delta;\n            return (await this.#noncePromise) + delta;\n        }\n\n        return super.getNonce(blockTag);\n    }\n\n    /**\n     *  Manually increment the nonce. This may be useful when managng\n     *  offline transactions.\n     */\n    increment(): void {\n        this.#delta++;\n    }\n\n    /**\n     *  Resets the nonce, causing the **NonceManager** to reload the current\n     *  nonce from the blockchain on the next transaction.\n     */\n    reset(): void {\n        this.#delta = 0;\n        this.#noncePromise = null;\n    }\n\n    async sendTransaction(tx: TransactionRequest): Promise<TransactionResponse> {\n        const noncePromise = this.getNonce(\"pending\");\n        this.increment();\n\n        tx = await this.signer.populateTransaction(tx);\n        tx.nonce = await noncePromise;\n\n        // @TODO: Maybe handle interesting/recoverable errors?\n        // Like don't increment if the tx was certainly not sent\n        return await this.signer.sendTransaction(tx);\n    }\n\n    signTransaction(tx: TransactionRequest): Promise<string> {\n        return this.signer.signTransaction(tx);\n    }\n\n    signMessage(message: string | Uint8Array): Promise<string> {\n        return this.signer.signMessage(message);\n    }\n\n    signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        return this.signer.signTypedData(domain, types, value);\n    }\n}\n"],"mappings":";;;;;;AAAA,MAAAA,UAAA,GAAAC,OAAA;AACA,MAAAC,oBAAA,GAAAD,OAAA;AAUA;;;;;AAKA,MAAaE,YAAa,SAAQD,oBAAA,CAAAE,cAAc;EAC5C;;;EAGAC,MAAM;EAEN,CAAAC,YAAa;EACb,CAAAC,KAAM;EAEN;;;EAGAC,YAAYH,MAAc;IACtB,KAAK,CAACA,MAAM,CAACI,QAAQ,CAAC;IACtB,IAAAT,UAAA,CAAAU,gBAAgB,EAAe,IAAI,EAAE;MAAEL;IAAM,CAAE,CAAC;IAEhD,IAAI,CAAC,CAAAC,YAAa,GAAG,IAAI;IACzB,IAAI,CAAC,CAAAC,KAAM,GAAG,CAAC;EACnB;EAEA,MAAMI,UAAUA,CAAA;IACZ,OAAO,IAAI,CAACN,MAAM,CAACM,UAAU,EAAE;EACnC;EAEAC,OAAOA,CAACH,QAAyB;IAC7B,OAAO,IAAIN,YAAY,CAAC,IAAI,CAACE,MAAM,CAACO,OAAO,CAACH,QAAQ,CAAC,CAAC;EAC1D;EAEA,MAAMI,QAAQA,CAACC,QAAmB;IAC9B,IAAIA,QAAQ,KAAK,SAAS,EAAE;MACxB,IAAI,IAAI,CAAC,CAAAR,YAAa,IAAI,IAAI,EAAE;QAC5B,IAAI,CAAC,CAAAA,YAAa,GAAG,KAAK,CAACO,QAAQ,CAAC,SAAS,CAAC;;MAGlD,MAAMN,KAAK,GAAG,IAAI,CAAC,CAAAA,KAAM;MACzB,OAAO,CAAC,MAAM,IAAI,CAAC,CAAAD,YAAa,IAAIC,KAAK;;IAG7C,OAAO,KAAK,CAACM,QAAQ,CAACC,QAAQ,CAAC;EACnC;EAEA;;;;EAIAC,SAASA,CAAA;IACL,IAAI,CAAC,CAAAR,KAAM,EAAE;EACjB;EAEA;;;;EAIAS,KAAKA,CAAA;IACD,IAAI,CAAC,CAAAT,KAAM,GAAG,CAAC;IACf,IAAI,CAAC,CAAAD,YAAa,GAAG,IAAI;EAC7B;EAEA,MAAMW,eAAeA,CAACC,EAAsB;IACxC,MAAMZ,YAAY,GAAG,IAAI,CAACO,QAAQ,CAAC,SAAS,CAAC;IAC7C,IAAI,CAACE,SAAS,EAAE;IAEhBG,EAAE,GAAG,MAAM,IAAI,CAACb,MAAM,CAACc,mBAAmB,CAACD,EAAE,CAAC;IAC9CA,EAAE,CAACE,KAAK,GAAG,MAAMd,YAAY;IAE7B;IACA;IACA,OAAO,MAAM,IAAI,CAACD,MAAM,CAACY,eAAe,CAACC,EAAE,CAAC;EAChD;EAEAG,eAAeA,CAACH,EAAsB;IAClC,OAAO,IAAI,CAACb,MAAM,CAACgB,eAAe,CAACH,EAAE,CAAC;EAC1C;EAEAI,WAAWA,CAACC,OAA4B;IACpC,OAAO,IAAI,CAAClB,MAAM,CAACiB,WAAW,CAACC,OAAO,CAAC;EAC3C;EAEAC,aAAaA,CAACC,MAAuB,EAAEC,KAA4C,EAAEC,KAA0B;IAC3G,OAAO,IAAI,CAACtB,MAAM,CAACmB,aAAa,CAACC,MAAM,EAAEC,KAAK,EAAEC,KAAK,CAAC;EAC1D;;AAhFJC,OAAA,CAAAzB,YAAA,GAAAA,YAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}